# Cpp基本语法

## 输入与输出

### cin 与 cout

```cpp
std::cin >> x >> y;                // 读入 x 和 y
std::cout << y << std::endl << x;  // 输出 y，换行，再输出 x
```

`std` 是 C++ 标准库所使用的 **命名空间**。使用命名空间是为了避免重名。C++ 标准库中的所有功能都在 `std` 命名空间中定义。



### printf 与 scanf

```cpp
scanf("%d%d", &x, &y);   // 读入 x 和 y
printf("%d\n%d", y, x);  // 输出 y，换行，再输出 x
```

#### 一些利用占位符控制格式的方式

1. `%+1d` 表示长度为 1 的整型。在读入时，即使没有空格也可以逐位读入数字。在输出时，若指定的长度大于数字的位数，就会在数字前用空格填充，默认右对齐。`+`可以让正数也显示正号。

2. `%.6lf`，保留六位小数。这种写法可以与限定宽度占位符，结合使用。

   ```cpp
   // 输出为 "  0.50"
   printf("%6.2f\n", 0.5);
   ```

3. `%.5s`，保留字符串的前五个字符



#### 字面量

字面量是在代码里直接作为一个值的程序段，例如 `3` 就是一个 `int` 字面量，`'c'` 就是一个 char 字面量。



## 补充

### #define命令

`#define` 是一种预处理命令，用于定义宏，本质上是文本替换。

```cpp
#include <iostream>
#define n 233

// n 不是变量，而是编译器会将代码中所有 n 文本替换为 233，但是作为标识符一部分的
// n 的就不会被替换，如 fn 不会被替换成 f233，同样，字符串内的也不会被替换

int main() {
  std::cout << n;  // 输出 233
  return 0;
}
```

宏可以带参数，带参数的宏可以像函数一样使用

**使用 `#define` 是有风险的**（由于 `#define` 作用域是整个程序，因此可能导致文本被意外地替换，需要使用 `#undef` 及时取消定义）。

> 较为推荐的做法是：使用 `const` 限定符声明常量，使用函数代替宏。

```cpp
#include <iostream>
#define sum(x, y) x + y
// 这里应当为 #define sum(x, y) ((x) + (y))
#define square(x) ((x) * (x))

int main() {
  std::cout << sum(1, 2) << ' ' << 2 * sum(3, 5) << std::endl;
  // 输出为 3 11，因为 #define 是文本替换，后面的语句被替换为了 2 * 3 + 5
  int i = 1;
  std::cout << square(++i) << ' ' << i;
  // 输出未定义，因为 ++i 被执行了两遍
  // 而同一个语句中多次修改同一个变量是未定义行为（有例外）
}
```

#### 一些小技巧

但是，在 OI 中，`#define` 依然有用武之处（以下两种是不被推荐的用法，**会降低代码的规范性**）：

1. `#define int long long`+`signed main()`。通常用于避免忘记开 long long 导致的错误，或是调试时排除忘开 long long 导致错误的可能性。（也可能导致增大常数甚至 TLE，或者因为爆空间而 MLE）
2. `#define For(i, l, r) for (int i = (l); i <= (r); ++i)`、`#define pb push_back`、`#define mid ((l + r) / 2)`，用于减短代码长度。

`#define` 也有一些优点，比如结合 `#ifdef` 等预处理指令有奇效，可以在编译的时候通过 `-DLINUX` 来控制编译出的代码，而无需修改源文件。这还有一个优点：通过 `-DLINUX` 编译出的可执行文件里并没有其他操作系统的代码，那些代码在预处理的时候就已经被删除了。

```cpp
#ifdef LINUX
// code for linux
#else
// code for other OS
#endif
```

`#define` 还能使用 `#`、`##` 运算符，极大地方便调试。



# 变量（待完善

`int`是数据类型，`int a`声明一个整数类型的变量`a`

## 数据类型

C++ 的类型系统由如下几部分组成：

1. 基础类型（括号内为代表关键词/代表类型）
   1. 无类型/`void` 型 (`void`)
   2. （C++11 起）空指针类型 (`std::nullptr_t`)
   3. 算术类型
      1. 整数类型 (`int`)
      2. 布尔类型/`bool` 型 (`bool`)
      3. 字符类型 (`char`)
      4. 浮点类型 (`float`,`double`)
2. 复合类型

### 字符类型

字符类型使用**1个字节（8位）**存储，**只能表示一个字符**。占位符**`%c`**表示字符类型。

单引号只能包含一个字符，双引号表示字符串常量。

C 语言规定，**字符常量必须放在单引号里面。**

- `char`：用于表示字符，通常占用1个字节。
- `wchar_t`：用于表示宽字符，通常占用2或4个字节。
- `char16_t`：用于表示16位Unicode字符，占用2个字节。
- `char32_t`：用于表示32位Unicode字符，占用4个字节。

与其他整型不同，`char`、`signed char`、`unsigned char` 是 **三种不同的类型**。一般来说 `signed char`,`unsigned char` 不应用来存储字符，绝大多数情况下，这两种类型均被视作整数类型。

C 语言将其当作整数处理，字符类型就是宽度为一个字节的整数，每个字符对应一个整数（由 ASCII 码确定）。只要在字符类型的范围之内，整数与字符是可以互换的，都可以赋值给字符类型的变量。

> Tips：对于ASCⅡ码，小写字母=大写字母+32

```cpp
char a = 'B'; // 等同于 char a = 66;
char b = 'C'; // 等同于 char b = 67;

printf("%d\n", a + b); // 输出 133
```

单引号本身也是一个字符，如果要表示这个字符常量，必须使用反斜杠转义

```cpp
char t = '\'';
```





### 整数类型

比较常见的是使用**4个字节（32位）**存储一个`int`类型的值，*但是2个字节（16位）或8个字节（64位）也有可能使用*。`%d`表示十进制整数，`%i`表示整数。

> 16位（-2^15~2^15-1，-32,768 到 32,767）
>
> 32位（-2^31~2^31-1，-2,147,483,648 到 2,147,483,647）
>
> 64位（-2^ 63~2^63-1，-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。）

#### signed, unsigned

C 语言使用`signed`关键字，表示一个类型带有正负号，包含负值；

使用`unsigned`关键字，表示该类型不带有正负号，只能表示零和正整数。`%u`表示无符号整数。



#### 整数的子类型

- `char`：一般占用1个字节

- `short (int)`：占用空间不多于`int`，一般占用**2个字节**。(`%hd` 表示十进制短整型 )

- `long (int)`：占用空间不少于`int`，**一般为4个字节，可能占用8个字节**，同`int`。(`%ld` 表示十进制长整型 )

- ``long long (int)`：占用空间多于`long`，**8个字节**。(`%lld` 表示十进制长长整型)

  > `signed, unsigned, short, long, long long, float, double, bool, char, wchar_t` 都属于修饰符
  
  

#### 进制

- 八进制使用**`0` **作为前缀，`%o`表示八进制整数。
- 十六进制使用`0x`作为前缀，`%x`表示十六进制整数。

不同的进制只是整数的书写方法，不会对整数的实际存储方式产生影响。所有整数都是二进制形式存储，跟书写方式无关。**不同进制可以混合使用**



### 定宽整数类型

C++11 起提供了定宽整数的支持，具体如下：

> 需要引入的头文件：
>
> `<cstdint>`：提供了若干定宽整数的类型和各定宽整数类型最大值、最小值等的宏常量。
>
> `<cinttypes>`：为定宽整数类型提供了用于 `std::fprintf` 系列函数和 `std::fscanf` 系列函数的格式宏常量。

定宽整数有如下几种：

- `intN_t`: 宽度 **恰为** N 位的有符号整数类型，如 `int32_t`.
- `int_fastN_t`: 宽度至少 有 N 位的 **最快的** 有符号整数类型，如 `int_fast32_t`.
- `int_leastN_t`: 宽度至少有 N 位的 **最小的** 有符号整数类型，如 `int_least32_t`.

无符号版本只需在有符号版本前加一个字母 u 即可，如 `uint32_t`,`uint_least8_t`

在实现了对应类型的情况下，C++ 标准规定必须实现表示对应类型的最大值、最小值、位宽的宏常量，格式为将类型名末尾的 `_t` 去掉后转大写并添加后缀：

- `_MAX` 表示最大值，如 `INT32_MAX` 即为 `int32_t` 的最大值。
- `_MIN` 表示最小值，如 `INT32_MIN` 即为 `int32_t` 的最小值。

> 注意：定宽整数类型本质上是普通整数类型的类型别名，所以**混用定宽整数类型和普通整数类型可能会影响跨平台编译**，例如：
>
> ```cpp
> #include <algorithm>
> #include <cstdint>
> #include <iostream>
> 
> int main() {
>   long long a;
>   int64_t b;
>   std::cin >> a >> b;
>   std::cout << std::max(a, b) << std::endl;
>   return 0;
> }
> ```
>
> `int64_t` 在 64 位 Windows 下一般为 `long long int`, 而在 64 位 Linux 下一般为 `long int`, 所以这段代码在使用 64 位 Linux 下的 GCC 时不能通过编译，而使用 64 位 Windows 下的 MSVC 时可以通过编译，因为 `std::max` 要求输入的两个参数类型必须相同。



### 浮点类型

float类型占用**4个字节（32位）**，其中**8位存放指数的值和符号**，剩下**24位存放小数的值和符号**，提供6~9精度位数。`%f`表示浮点数。

- `double`：占用**8个字节（64位）**，提供15~17精度位数。**`%lf`** 表示双精度浮点数 。

  > 因为 `float` 类型表示范围较小，且精度不高，**实际应用中常使用 `double` 类型表示浮点数**

- `long double`：通常占用**16个字节**，提供33~36的精度位数。**`%lld` **表示长整型浮点数。

![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png)

注意，由于存在精度限制，**浮点数只是一个近似值，它的计算是不精确的**，比如 C 语言里面0.1 + 0.2并不等于0.3，而是有一个很小的误差。



## 类型转换（待完善

### 数值提升



### 数值转换





## 定义变量

标识符是可以用作变量名的一组字符。标识符由英文字母、下划线开头，中间只允许出现英文字母、下划线和数字。关键字不能用作标识符。

> 当变量声明后立即对其**初始化**，否则可能会导致未定义行为

> 定义时没有初始化值的全局变量会被初始化为`0`。而局部变量没有这种特性，需要手动赋初始值，否则可能引起难以发现的 bug。



## 常量

常量是固定值，在程序执行期间不会改变。

常量的值在定义后不能被修改。定义时加一个 `const` 关键字即可。

> `const, volatile, restrict, mutable, static, register`都属于类型限定符



## typedef 声明

可以使用 typedef 为**已有的数据类型**定义一个新的别名。可以为复杂的类型（如**结构体、函数指针、数组等**）起个更简洁、更具描述性的名字，这样可以让代码更加简洁、易懂。

它的主要目的是增强代码的可读性、简化类型声明、方便维护和修改。当类型发生变化时，**只需要修改 `typedef` 的定义**，而不需要逐个修改所有相关的类型声明。

```cpp
简化类型声明/*为基本数据类型定义别名*/
typedef unsigned int uint;
typedef long long ll;
uint a = 100;  // 相当于 unsigned int a = 100;
ll b = 1234567890123;  // 相当于 long long b = 1234567890123;

/*为结构体定义别名*/
struct Person {
    char name[50];
    int age;
};
typedef struct Person Person;  // Person 成为 struct Person 的别名
Person p1;  // 等同于 struct Person p1;

/*为函数指针定义别名，形式略有不同*/
typedef int* int_ptr;  // int_ptr 是 int* 的别名
int_ptr p1, p2;  // 相当于 int* p1, p2;


/*为函数指针定义别名*/
typedef int (*func_ptr)(int);
func_ptr fp;

/*为数组类型定义别名*/
typedef int arr10[10];
arr10 a;

```



# 运算

## 算数运算符

`/` 除法运算符，求商

`%` 取模运算符，求余数

`++` 自增运算符

`--` 自减运算符



### 自增 / 自减运算符

**`i++`返回`i` 的原始值，`++i`返回`i` 的新值**

```cpp	
i = 100;
op1 = i++;  // op1 = 100，先 op1 = i，然后 i = i + 1

i = 100;
op2 = ++i;  // op2 = 101，先 i = i + 1，然后赋值 op2

```

```cpp
int i = 5;
int a = i++ + i++; 
//a = 11, 第一个 i++：返回 5，i 变为 6。第二个 i++：返回 6，i 变为 7。计算 5 + 6，结果为 11。将 11 赋给 a
```



## 杂项运算符

`sizeof()` 返回变量的大小

**`a ? b : c`**  条件运算符。如果表达式 `a` 成立，那么这个条件表达式的结果是 `b`，否则条件表达式的结果是 `c`。可以看作 `if` 语句的简写。

`->`和`.` 成员运算符。通过指针来访问指向对象的成员（包括**结构体、类、函数**等）



# 流程控制语句（待完善

## 分支 / 判断（待完善

Duff's Device



## 循环

### `for / while /do...while`的联系

三种语句可以彼此代替，但一般来说，语句的选用遵守以下原则：

> 循环过程中**有固定的增加步骤（最常见的是*枚举*）时**，使用 for 语句；
>
> 只确定循环的**终止条件**时，使用 while 语句；
>
> 使用 while 语句时，若要先执行循环体再进行判断，使用 do...while 语句。一般很少用到，常用场景是*用户输入*。



### `break / continue`的区别

`break`用于**退出整个循环**，`continue` 语句用于**跳过当前迭代的剩余部分，并立即开始下一次迭代**。

```cpp
for (int i = 1; i <= n; ++i) {
    if (i == x) break;
    // do something...
}// 循环在 i 等于 x 时终止

for (int i = 1; i <= n; ++i) {
    if (i == x) continue;
    // do something...
}// 循环在 i 等于 x 时**跳过当前迭代，继续下一个 i 的值**
```



### 无限循环

如果条件永远不为假，则循环将变成无限循环。**当条件表达式不存在时，它被假设为真**。**for** 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。

```cpp
for( ; ; )
   {
      printf("This loop will run forever.\n");
   }

```





### 一些优质实践

```cpp
// 逻辑较为不清晰，大括号层次复杂
for (int i = 1; i <= n; ++i) {
  if (i != x) {
    for (int j = 1; j <= n; ++j) {
      if (j != x) {
        // do something...
      }
    }
  }
}

// 逻辑更加清晰，大括号层次简单明了
for (int i = 1; i <= n; ++i) {
  if (i == x) continue;
  for (int j = 1; j <= n; ++j) {
    if (j == x) continue;  //跳过 i,j == x 
    // do something...
  }
}
```

外层循环的 `i` 从 `1` 到 `n` 进行迭代。每次 `i` 迭代时，内层循环的 `j` 从 `1` 到 `n` 进行迭代。如果 `j` 等于 `x`，`continue` 语句会跳过当前的 `j` 迭代，继续下一个 `j` 的值。



```cpp
// for 语句判断条件复杂，没有体现「枚举」的本质
for (int i = l; i <= r && i % 10 != 0; ++i) {
  // do something...
}

// for 语句用于枚举，break 用于「到何时为止」
for (int i = l; i <= r; ++i) {
  if (i % 10 == 0) break;
  // do something...
}
```



```cpp
// 语句重复，顺序不自然
statement1;
while (statement3) {
  statement2;
  statement1;
}

// 没有重复语句，顺序自然
while (1) {
  statement1;
  if (!statement3) break;
  statement2;
}
```



# 指针

## 指针的声明与使用

在 32 位机上，地址用 32 位二进制整数表示，因此一个指针的大小为 4 字节。而 64 位机上，地址用 64 位二进制整数表示，**因此一个指针的大小恒定为 8 字节。**

指针变量也有不同的类型，比如，可以有 `int` 类型的指针变量，其中存储的地址（即指针变量存储的数值）**对应（而并非指针变量本身）**一块大小为 32 位的空间的**起始地址**；有 `char` 类型的指针变量，其中存储的地址**对应**一块 8 位的空间的**起始地址**。用户也可以声明指向指针变量的指针变量。

```cpp
int main() {
  int a = 123;  // a: 123
  int* pa = &a;
  *pa = 321;  // a: 321
}
```



## 指针的算术运算

指针变量也可以和**整数**进行加减操作。对于**指向相同数组**的指针，还可以通过关系比较确定一个指针指向的位置在另一个指针之前或之后。

> 对于 `int` 型指针，每加 1（递增 1），其指向的地址偏移 32 位（即 4 个字节）；若加 2，则指向的地址偏移 2 × 32 = 64 位。
>
> 对于 `char` 型指针，每次递增，其指向的地址偏移 8 位（即 1 个字节）。

### 使用指针偏移访问数组

数组是一块连续的存储空间。而在 C/C++ 中，直接使用数组名，得到的是数组的起始地址。

```cpp
int main() {
  int a[3] = {1, 2, 3};
  int* p = a;  // p 指向 a[0]
  *p = 4;      // a: [4, 2, 3]
  p = p + 1;   // p 指向 a[1]
  *p = 5;      // a: [4, 5, 3]
  p++;         // p 指向 a[2]
  *p = 6;      // a: [4, 5, 6]
}
```



## Null 指针（待完善

（c11前后 Null 指针的变化显著）

赋为 NULL 值的指针被称为空指针。NULL 指针是一个定义在标准库中的值为零的常量。

```cpp
#include <iostream>

using namespace std;

int main ()
{
   int  *ptr = NULL;

   cout << "ptr 的值是 " << ptr ;
 
   return 0;
}
```

在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。**但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。**

> 在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。如果所有未使用的指针都被赋予空值，同时避免使用空指针，就可以防止误用一个未初始化的指针。

如需检查一个空指针，可以使用 if 语句，如下所示：

```
if(ptr)     /* 如果 ptr 非空，则完成 */
if(!ptr)    /* 如果 ptr 为空，则完成 */
```



## 向函数传入指针、从函数返回指针

在 C/C++ 中，调用函数（过程）时使用的参数，均以拷贝的形式传入子过程中（引用除外，会在后续介绍）。默认情况下，函数仅能通过返回值，将结果返回到调用处。

但是，如果**某个函数希望修改其外部的数据，或者某个结构体/类的数据量较为庞大、不宜进行拷贝**，这时，则可以通过向其传入外部数据的地址，便得以在其中访问甚至修改外部数据。

下面的 `my_swap` 函数，通过接收两个 `int` 型的指针，直接对两变量进行操作，绕过了输入参数再返回值的过程。

```cpp
void my_swap(int *a, int *b) {
  int t;
  t = *a;  //直接在函数内对地址进行操作
  *a = *b;
  *b = t;
}

int main() {
  int a = 6, b = 10;
  my_swap(&a, &b);
}
```

> 调用函数时，有3种向函数传递参数的方式：传值调用、指针调用、引用调用。C++ 中引入了引用的概念，相对于指针来说，更易用，也更安全。参考 *函数的参数*

下面的 `updateAge` 函数通过接收一个指向结构体的指针，直接对外部结构体进行操作，相较于`printOerson`函数避免了传递结构体副本的过程。

```cpp
struct Person {
    string name;
    int age;
};
// 按值传递结构体
void printPerson(Person p) {
    cout << "Name: " << p.name << ", Age: " << p.age << endl;
}
void updateAge(Person* p){
    p->age += 1;  // 通过指针修改原始结构体
    cout << "After: " << (*p).name << " " << (*p).age << endl;
}
int main() {
    Person p1 = {"John", 30};
    printPerson(p1);  // 传递结构体副本
    updateAge(&p1);  // 传递结构体指针
    return 0;
}
```



C++也可以从函数中返回指针，首先需要声明并定义一个返回函数的指针。

**注意，C++ 不支持在函数外返回局部变量的地址**。当函数结束时，局部结构体将被销毁，返回的指针会指向一个已经销毁的内存区域，这样会导致未定义行为。常见的作法是使用 static 变量或动态分配内存。

```cpp
#include <iostream>

int* createArray(int size) {
    int* arr = new int[size];  // 使用new动态分配内存创建数组并返回指向该数组的指针
    for (int i = 0; i < size; ++i) {  // 初始化数组元素
        arr[i] = i * 10;
    }
    return arr; // 返回指向数组的指针
}

int main() {
    int size = 5;
    int* array = createArray(size); // 获取返回的指针
    for (int i = 0; i < size; ++i) {  // 输出数组内容
        cout << array[i] << " ";
    }
    cout << endl;
    delete[] array;  // 使用完指针后要释放内存
    return 0;
}

```

作为对照，如果在`createArray`函数中直接返回一个**局部**数组的指针，那么`arr` 是在栈上分配的局部变量。**当 `createArray` 函数返回时，栈上的内存被清除**，`arr` 数组也随之销毁。此时，返回的指针变为悬挂指针，该指针不再指向有效的内存地址，任何对该指针的访问都会导致未定义行为，例如程序崩溃或者输出垃圾值。

再次体现了了**动态分配内存**的重要性

```cpp
int* createArray(int size) {
    int arr[size];  // 在栈上分配的局部数组
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 10;
    }
    return arr;  // 返回局部数组的指针
}
```



## 指针数组

> 注意：**数组指针**和**指向数组首元素的指针**和**指向数组的指针**是几个不同的概念

指针数组是一个数组，数组中的每个元素都是一个指针。也就是说，**数组的每个元素都是指向某个数据类型的指针**。指针数组的定义形式如下：

```cpp
   int  var[MAX] = {10, 100, 200};
   int* ptr[MAX];
   char* names[MAX] = {
                   "Zara Ali",
                   "Hina Ali",
                   "Nuha Ali",
                   "Sara Ali",
   };  // "Zara Ali"、"Hina Ali" 等都是 **被指向的量**，例如 names[0] 指向字符串 "Zara Ali"
```



# 引用

引用变量是一个别名，也就是说，它是某个已存在变量的 “另一个名字”。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

我在什么时候需要使用引用？

- 避免不必要的拷贝开销：当你传递大的对象（如**大数组、大类、对象或容器**）时，使用引用可以避免不必要的拷贝开销。

- 允许修改原始对象：如果你希望在函数内部修改传入的参数，而不只是读取它，可以使用非 `const` 引用。这意味着你传递的是变量的直接别名，**修改它会影响到原始对象（类似指针）**。

- 操作符重载：引用常用于重载操作符，尤其是赋值操作符，以实现对对象的直接操作而非复制。

  

引用**必须在定义时初始化**，并且一旦绑定到一个变量后，就**不能再绑定到其他变量**。

````cpp
int a = 10;
int &ref = a;  // ref 是 a 的引用
````

- `int &ref` 表示 `ref` 是一个 `int` 类型的引用。

- `ref` 是 `a` 的别名，对 `ref` 的操作会直接作用于 `a`。



## C++中引用 VS 指针

引用很容易与指针混淆，它们之间有四个甚至三个主要的不同：

- 不存在空引用，引用必须连接到一块合法的内存。因此引用也相对安全，且语法更直观。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。
- **引用的对象必须是一个变量，而指针必须是一个地址**。

指针仍然是不可取代的。对于**动态内存管理**，指针是操作堆内存的唯一方式（如 `new` 和 `delete`）；对于**复杂的数据结构**，如链表、树等，需要指针来实现灵活的连接；作为**可选参数**，指针可以为空（`nullptr`），适合表示可选参数或空值。



## > 为什么我们仍然需要引用？

引用是C++引入的一种更安全、更直观的间接访问机制。它的主要目能够提供一种**更简洁的语法**来操作数据，避免指针的复杂性和潜在的错误。

```cpp
int x = 10;
int &ref = x;  // ref 是 x 的引用
ref = 20;      // 直接修改 x 的值，不需要解引用
```

相比之下，使用指针需要显式地解引用：

```cpp
int *ptr = &x;
*ptr = 20;     // 需要解引用
```



## 向函数传入引用、从函数返回引用

可以将指针作为参数调用函数，同样也可以将引用作为参数调用函数。

```cpp
#include <iostream>
using namespace std;
 
void swap(int& x, int& y);
 
int main ()
{
   int a = 100;
   int b = 200;
   cout << "交换前，a 的值：" << a << endl;
   cout << "交换前，b 的值：" << b << endl;
   swap(a, b);
   cout << "交换后，a 的值：" << a << endl;
   cout << "交换后，b 的值：" << b << endl;
   return 0;
}
 
void swap(int& x, int& y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}
```



同样的，与函数返回指针类似，函数也可以将引用作为返回值。当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以**放在赋值语句的左边接受赋值**。

```cpp
#include <iostream>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues(int i) {  
   double& ref = vals[i];    
   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]
}

int main ()
{
   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   setValues(1) = 20.23; // 改变第 2 个元素，函数返回值为引用，作为左值接受赋值
   setValues(3) = 70.8;  // 改变第 4 个元素
   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}
```

**注意，C++ 不支持在函数外返回局部变量的地址**。当函数结束时，局部结构体将被销毁，返回的指针会指向一个已经销毁的内存区域，这样会导致未定义行为。常见的作法是使用 static 变量或动态分配内存。

```cpp
int& func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```

注意，静态变量 `num` **只会在第一次调用 `getStaticRef()` 时初始化为 `5`，后续调用时不会再重新初始化。**第二次调用 `getStaticRef()` 时，`num` 的值不变。

> \> *静态变量*



# 函数

## 函数的定义

```cpp
return_type function_name( parameter list )
{
   body of the function
}
```

- **返回类型：**一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。



## 声明函数（待完善

```cpp
int max(int num1, int num2);
```

**在函数声明中，参数的名称并不重要**，只有参数的类型是必需的，因此下面也是有效的声明：

```cpp
int max(int, int);
```

**当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的**。在这种情况下，您应该在调用函数的文件顶部声明函数。



### > 为什么需要先声明再调用函数？（待完善



## 调用函数

当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。



## 函数的参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

当调用函数时，有三种向函数传递参数的方式：

| 调用类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [传值调用](https://www.runoob.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |
| [指针调用](https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，**修改形式参数会影响实际参数**。 |
| [引用调用](https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，**修改形式参数会影响实际参数**。 |

默认情况下，C++ 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。

### 参数的默认值

定义一个函数，可以为参数列表中后边的每一个参数指定默认值。当调用函数时，**如果实际参数的值留空，**则使用这个默认值。如果指定了值，则会忽略默认值，使用传递的值。



## 函数指针

**一定程度上，函数是基于指针实现的**

这里的“基于指针”指的是函数本身在内存中的表示方式。函数存放在内存的代码区域内，它们同样有地址，即为函数的名字。在调用时，程序会通过这个指针跳转到函数的内存位置，执行相应的操作。这一点如同数组一样，数组的名字就是数组的起始地址。

注意，函数指针所指向的函数一定要保持函数的**返回值类型**，函数**参数个数、类型一致**。

```cpp
int (*fp)(int a);  // 这里就定义了一个指向函数 (这个函数参数为一个 int 类型，函数返回值是 int 类型) 的指针 fp。
```

通过函数指针，我们可以显式地操作这个“函数的内存地址”。函数指针是一个存储函数地址的变量，它**允许我们在运行时动态地选择调用哪个函数**，而不需要硬编码函数名。

```cpp
int add(int a, int b) {
    return a + b;
}
int subtract(int a, int b) {
    return a - b;
}

int main() {
    // 声明一个指向函数的指针
    int (*func_ptr)(int, int);
    
    // 指向 add 函数
    func_ptr = add;
    printf("%d\n", func_ptr(10, 5));  // 输出 15

    // 指向 subtract 函数
    func_ptr = subtract;
    printf("%d\n", func_ptr(10, 5));  // 输出 5

    return 0;
}
```



### 函数与指针的隐式转换

函数（如 `foo`）是能够被隐式转换为指向函数的指针的，因此 `void (*p)() = foo;` 的写法能够成立。使用 `&` 运算符可以取得到对象的地址，这对函数也是成立的，因此 `void (*p)() = &foo;` 的写法仍然成立。

```cpp
int test(int a)
{
    return a;
}
int main(int argc, const char * argv[])
{
    
    int (*fp)(int a);
    fp = test;  // 函数名被隐式转换为指针
    cout<<fp(2)<<endl;
    return 0;
}
```



对于 `**foo` 这样的写法来说，`*foo` 得到的是 `foo` 这个函数，紧接着又被隐式转换为指向 `foo` 的指针。如此类推，`**foo` 得到的最终还是指向 `foo` 的函数指针。

> 用户尽可以使用任意多的 `*`，结果也是一样的。同理，在调用时使用类似 `(*p)()` 和 `p()` 的语句是一样的，可以省去 `*` 运算符。



## 向函数传递函数，从函数返回函数

可以通过**函数指针**来向函数传递另一个函数。假设我们有一个函数 `add`，我们可以将它作为参数传递给另一个函数。

函数声明中，**`int (*func)(int, int)`** 是一个 输入两个 `int` 参数，返回一个 `int` 参数的 **函数指针** 

```cpp
#include <iostream>

// 定义一个接受两个整数并返回一个整数的函数
int add(int a, int b) {
    return a + b;
}
// 接受一个函数指针的函数
int apply(int (*func)(int, int), int a, int b) {

    return func(a, b);  // 使用传入的函数指针
}

int main() {
    int result = apply(add, 3, 4);  // 向apply函数传递add函数
    std::cout << "Result: " << result << std::endl;  // 输出结果：7
    return 0;
}
```

在C++中，**不能直接返回一个函数**，因为函数名代表的只是函数的地址（而不是整个函数本身）。但可以通过以下方式返回一个函数指针，或者更常见的做法是返回一个函数对象（即返回一个“可调用对象”）

注意，函数声明中，**`int (*getOperation(char op))(int, int)`**中，`getOperation` 是一个函数，接收一个 `char` 类型的参数 `op`，**返回类型是 `int (*)(int, int)`，即返回一个指向 `int` 类型函数的指针**，这个函数接受两个 `int` 类型的参数，并返回 `int` 类型的值。

注意，`int *getOperation(char op)(int, int)`是错误的。

```cpp
#include <iostream>

// 定义两个函数
int add(int a, int b) {
    return a + b;
}
int multiply(int a, int b) {
    return a * b;
}
// 返回一个函数指针
int (*getOperation(char op))(int, int) {
    if (op == '+') {
        return add;  // 返回指向add函数的指针
    } else if (op == '*') {
        return multiply;  // 返回指向multiply函数的指针
    }
    return nullptr;  // 如果op不符合，返回空指针
}

int main() {
    // 获取操作符对应的函数指针
    int (*operation)(int, int) = getOperation('+');
    if (operation) {   // 检查函数指针是否为空指针
        cout << "3 + 4 = " << operation(3, 4) << endl;  // 输出结果：7
    }
    
    operation = getOperation('*');
    if (operation) {
        cout << "3 * 4 = " << operation(3, 4) << endl;  // 输出结果：12
    }
    
    return 0;
}
```

> 是的这很奇怪，但是：
>
> ```cpp
> int* a;  // 创建一个 int 类指针 a
> void Example(int* a);  // 向函数传入一个 int 类指针
> int* eXample(void);  // 从函数返回一个 int 类指针
> 
> int (*func)(int a);  // 创建一个函数指针 func
> int exAmple(int (*func)(int, int))  // 向函数传入一个函数指针
> int (*func(int a))(int, int)   // 从函数返回一个函数指针
> ```
>
> 所以对照来看并不是非常奇怪

> 如果头铁不想用 `int (*getOperation(char op))(int, int)`这样绕绕绕的表达，下面是使用普通指针的方式，在函数体内进行运算，返回的是结果地址。
>
> 但这样的写法已与原本的代码产生了一定的区别，函数指针仍然是不可替代的。
>
> ```cpp
> int* getOperation(char op, int a, int b) {
>     static int result;  // 使用 static 保证 result 在函数外部仍然有效
>     
>     if (op == '+') {
>         result = add(a, b);  // 计算加法并存储结果
>         return &result;  // 返回指向结果的指针
>     } else if (op == '*') {
>         result = multiply(a, b);  // 计算乘法并存储结果
>         return &result;  // 返回指向结果的指针
>     }
>     return nullptr;  // 如果操作符不符合，返回空指针
> }
> ```
>



## Lambda 函数与表达式（待完善









# 数字

## 数学运算

C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。这些函数写在标准 C 和 C++ 库中，叫做内置函数。

> 为了利用这些函数，需要引用数学头文件 **<cmath>**

| 序号 | 函数 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | double cos(double); 该函数返回弧度角（double 型）的余弦。    |
| 2    | double sin(double); 该函数返回弧度角（double 型）的正弦。    |
| 3    | double tan(double); 该函数返回弧度角（double 型）的正切。    |
| 4    | double log(double); 该函数返回参数的自然对数。               |
| 5    | **double pow(double, double);** 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 |
| 6    | **double hypot(double, double);** 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 |
| 7    | **double sqrt(double);** 该函数返回参数的平方根。            |
| 8    | **int abs(int);** 该函数返回**整数**的绝对值。               |
| 9    | **double fabs(double);** 该函数返回任意一个**浮点数**的绝对值。 |
| 10   | **double floor(double);** 该函数返回一个小于或等于传入参数的最大整数。(高斯函数) |



## C++随机数

关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 **srand()** 函数。`srand()` 是一个用于设置随机数生成器种子的函数，`rand()` 用于生成伪随机数，而 `srand()` 用来控制这些随机数的生成方式。

> 为了利用这些函数，需要引用时钟头文件 **<ctime>**

`seed` 是一个整数值，用于初始化随机数生成器的种子。不同的种子值会生成不同的随机数序列。通常使用 `time(NULL)` 来获取当前的时间戳作为种子，这样每次运行程序时，生成的随机数序列都会不同。

```cpp
void srand(unsigned int seed);
```

`srand()` 函数的作用是给伪随机数生成器设置一个初始值（种子）。当使用 `rand()` 函数生成随机数时，`rand()` 会根据这个种子值生成一个伪随机数序列。如果没有调用 `srand()`，则 `rand()` 会使用一个默认的固定种子（通常为 1），这就会导致每次运行程序时生成的随机数序列都是相同的。

下面是一个关于生成随机数的简单实例。实例中使用了 **time()** 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：

```cpp
#include <iostream>
#include <ctime>
#include <cstdlib>
 
using namespace std;
 
int main ()
{
   int i,j;
   srand( (unsigned)time( NULL ) );  // 设置种子
   for( i = 0; i < 10; i++ )  // 生成 10 个随机数
   {
      j= rand();  // 生成实际的随机数
      cout <<"随机数： " << j << endl;
   }
   return 0;
}
```



# 数组

数组是存放**相同类型对象**的容器，数组中存放的对象没有名字，而是要通过其所在的位置访问。数组的**大小固定**，不能随意改变数组的长度。

## 定义与初始化数组

数组的声明形如 `a[d]`，其中，`a` 是数组的名字，`d` 是数组中元素的个数。**在编译时，`d` 应该是已知的，也就是说，`d` 应该是一个整型的常量 `(const)`表达式**。

```cpp
unsigned int d1 = 42;
**const** int d2 = 42;
int arr1[d1];  // 错误：d1 不是常量表达式
int arr2[d2];  // 正确：arr2 是一个长度为 42 的数组
```

不能将一个数组直接赋值给另一个数组。

> **应该尽量将较大的数组定义为全局变量**。因为局部变量会被创建在栈区中，过大（大于栈的大小）的数组会爆栈，进而导致 RE。如果将数组声明在全局作用域中，就会在静态区中创建数组。



数组可以逐个元素初始化，也可以使用一个初始化语句。如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。如下例将创建一个数组，它与前一个实例中所创建的数组是完全相同的。

> 建议在定义数组时就完成数组的初始化

```cpp
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```



## 访问和修改数组元素

可以通过下标运算符 `[]` 来访问数组内元素，数组的索引（即方括号中的值）从 0 开始。

> 在 OI 中，为了使用方便，我们通常会将数组开大一点，不使用数组的第一个元素，从下标 1 开始访问数组元素。
>
> 经常使用`for`（嵌套）循环来处理（多元）数组。

```cpp
const int MAXN = 1001;
int pic[MAXN][MAXN];
int n, m;

cin >> n >> m;
for (int i = 1; i <= n; ++i)
  for (int j = 1; j <= m; ++j) cin >> pic[i][j];
```

上例是一个多维数组，从标准输入中读取两个数`n`与`m`，分别表示黑白图片的高与宽。对于接下来的`n`行数据，每行有用空格分隔开的`m`个数，代表这一位置的亮度值。现在我们读取这张图片，并将其存入二维数组中。



## 数组指针

**数组本质上是基于指针运行的。**

指针和数组在很多情况下是可以互换的。当我们在 C/C++ 中传递一个数组时，**实际上传递的是该数组首元素的地址**，数组名 `var` 代表的是一个指向该数组首元素的指针。

```cpp
   int  var[MAX] = {10, 100, 200};
   int  *ptr;
   // 指针中的数组地址
   ptr = var;  //数组名可被隐式转换为指针
   for (int i = 0; i < MAX; i++)
   {
      cout << "var[" << i << "]的内存地址为 ";
      cout << ptr << endl;
 
      cout << "var[" << i << "] 的值为 ";
      cout << *ptr << endl;
 
      // 移动到下一个位置
      ptr++;
   }
```

需要注意的是，数组名 `var` 实际上是一个**常量**指针，指向数组首元素的地址，而指针 `ptr` 是一个普通的变量，可以改变它的值，指向不同的地址。

```cpp
	*var = i;    // 这是正确的语法
	var++;       // 这是不正确的
	var = ptr    // 这也是不正确的
```

### 数组名与指针的隐式转换

数组名在表达式中通常会被**隐式转换为指向其首元素的指针**，不需要显式地使用取地址符 `&`，但**反过来是不会自动发生的**。同样的过程也发生在函数中。

访问数组元素时，**对于 `arr[i]` ，C/C++ 编译器会把这个表达式解释为 `*(arr + i)`。**数组名 `arr` 被隐式转换为指向数组首元素的指针。

`arr[0]` 等价于 `*(arr + 0)`，即访问数组的第一个元素。`arr[1]` 等价于 `*(arr + 1)`，即访问数组的第二个元素。依此类推，`arr[i]` 等价于 `*(arr + i)`，即访问数组的第 `i` 个元素。

```cpp
int main (){
	int balance[5] = {1000, 2, 3, 17, 50};  //balance 被隐式转换为指向数组首元素的指针（int* 类型）
	double avg;
	avg = getAverage( balance, 5 ) ;  // 传递一个指向数组**首元素**的指针作为参数
	cout << "Average value is: " << avg << endl;
}
double getAverage(int *arr, int size){
	double sum = 0;       
	double avg;          
	for (int  i = 0; i < size; ++i)
	{
        sum += arr[i];
        // **当我们写 arr[i] 时，C/C++ 编译器会把这个表达式解释为 *(arr + i)**
	}
 	avg = sum / size;
  	return avg;
}
```

所以

```cpp
double getAverage(int *arr, int size){
    sum += arr[i];
}
```

之中并不是指针`arr`被转换为了数组，而是数组`arr[i]`转换为了指针。



## 向函数传入数组、从函数返回数组

如果想要在函数中传递一个数组作为参数，可以以下面三种方式来声明函数形式参数。这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。同样地，也可以传递一个多维数组作为形式参数。

```cpp
void myFunction(int *param){  // 形式参数是一个指针
}
void myFunction(int param[10]){  // 形式参数是一个已定义大小的数组
}
void myFunction(int param[]){  // 形式参数是一个未定义大小的数组
}
```

如果想要从函数返回一个一维数组，必须声明一个返回**数组指针**的函数

```cpp
int* myFunction() {
}
```

**注意，C++ 不支持在函数外返回局部变量的地址**，除非定义局部变量为 static 变量。当函数结束时，局部数组将被销毁，返回的指针会指向一个已经销毁的内存区域，这样会导致未定义行为。常见的做法是使用**静态数组**或者[*动态分配数组*](##动态分配数组)。

```cpp
int* myFunction()
{
   static int myArray[3] = {1, 2, 3};
   return myArray;
}
```





## 指向数组的指针

> 注意：**数组指针**和**指向数组首元素的指针**和**指向数组的指针**是几个不同的概念

指向数组的指针是一个指向**整个数组**（而不是数组中的单个元素）的指针。它的类型与保存的信息不仅包含数组元素的类型，**还包含数组的大小**。

```cpp
int(*ptr)[5] = &arr;  // ptr 是一个 **指向（包含 5 个 int 元素的）数组** arr 的指针，可以直接对数组取地址
int(*a)[5] = new int[5][5]; 
```

相较于普通（指向数组首元素的）指针：

```cpp
int *a = new int[5];  //*a 指向数组a的首元素  
int(*ptr) = &arr[1]
```

普通指针的步长是一个元素的大小（例如 `sizeof(int)`）。**指向数组的指针的步长是整个数组的大小（例如 `sizeof(int[5])`）**。对于`int[5]`，从概念上说代码中标识符 `a` 的类型是 `int[5]`；从实际上来说`a + 1` 所指向的地址相较于 `a` 指向的地址的偏移量为 **5 个** `int` 型变量的长度。

> \> 指向数组的指针在处理 [*多维数组*](##多维数组) 时非常有用。



可以通过指向数组的指针访问数组。使用 `int (*ptr)[5]` 时，通过 `*ptr` 可以访问整个数组，而不仅仅是首元素。此时，**`*ptr` 就相当于数组 `arr` 本身**。

```cpp
for (int i = 0; i < 5; i++) {
    printf("%d ", (*ptr)[i]);  // 通过 *ptr 访问数组元素，等同于 arr[i]
}
```

也可以在此基础上再引用指针偏移来访问数组中的元素

```cpp
for (int i = 0; i < 5; i++) {
    printf("%d ", *((*ptr) + i));
}
```

`(*ptr)` 解引用指针，相当于数组 `arr`；`(*ptr) + i` 通过指针偏移来访问数组的第 `i` 个元素；`*((*ptr) + i)` 对偏移后的地址解引用，得到具体的元素值



## 多维数组（？

下面的声明创建了一个三维 5 . 10 . 4 整型数组。

二维数组中的每个元素是使用形式为`a[ i , j ]` 的元素名称来标识的，其中 a 是数组名称，i 和 j 是唯一标识 a 中每个元素的下标。二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。

```cpp
int threedim[5][10][4];
int val = a[2][3][4];
```



从语义上来讲，二维数组是一个数组的数组。而计算机内存可以视作一个很长的一维数组，**一个二维数组在本质上是一个一维数组的列表**。要在计算机内存中存放一个二维数组，便有「连续」与否的说法。

所谓「连续」，即二维数组的任意一行（row）的末尾与下一行的起始，在物理地址上是毗邻的，换言之，整个二维数组可以视作一个一维数组；反之，则二者在物理上不一定相邻。

对于「连续」的二维数组，可以仅使用一个循环，借由一个不断递增的指针即可遍历数组中的所有数据。而对于非连续的二维数组，由于每一行不连续，则需要先取得某一行首的地址，再访问这一行中的元素。

> 按照「行（row）」存储数据的方式，称为行优先存储；相对的，也可以按照列（column）存储数据。由于计算机内存访问的特性，一般来说，访问连续的数据会得到更高的效率。因此，需要按照数据可能的使用方式，选择「行优先」或「列优先」的存储方式。



### 一种创建连续二维数组的方法

若要动态创建二维数组，常见的方式是声明一个长度为 N × M 的 **一维数组**，并通过下标**`r * M + c`**访问二维数组中下标为 `(r, c)` 的元素。**这种方法可以保证二维数组是连续的。**

```cpp
int* a = new int[N * M];
```



### 一种创建不一定连续二维数组的方法（？

此外，亦可以根据「数组的数组」这一概念来进行内存的获取与使用。**对于一个存放的若干数组的数组，实际上为一个存放的若干数组的首地址的数组，也就是一个存放若干指针变量的数组。**

我们需要一个变量来存放这个「数组的数组」的首地址——也就是一个指针的地址。这个变量便是一个「指向指针的指针」，有时也称作「二重指针」，如：

```cpp
int** a = new int*[5];  //创建含有6个元素的**指针数组**a
```

接着，我们需要为每一个数组申请空间：

```cpp
for (int i = 0; i < 5; i++) {
  a[i] = new int[5];  //指针数组a中的每个元素都是指针数组a的数组a[i]的首地址， 而每个数组a[i]含有6个元素，则构成了一个6*6二位数组
}
//此处为创建一维数组的语句 作对照
int* dynamicArray = new int[size]
```

至此，我们便完成了内存的获取。可以直接通过二维数组访问指定元素，或通过遍历为二维数组赋值并打印：

```cpp
a[2][3] = 42;
for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
        a[i][j] = i * 5 + j;
        cout << a[i][j] << " ";
    }
```

而对于这样获得的内存的释放，则需要进行一个逆向的操作：即先释放每一个数组，再释放存储这些数组首地址的数组，如：

``` cpp
for (int i = 0; i < 5; i++) {
  delete[] a[i];
}
delete[] a;
```

需要注意，这样获得的二维数组，**不能保证其空间是连续的。**



### 另外一种创建连续二维数组的方法（？

还有一种方式，需要使用到「指向数组的指针」。

```cpp
int main() {
  int(*a)[5] = new int[5][5];
//int(*a)[5] 是一个**指向数组**的指针，指向一个包含5个整数的数组。
//new int[5][5] 动态分配了一个5x5的二维数组，返回的是一个指向**第一个5元素数组a[0]**的指针。
  int* p = a[2];
  a[2][1] = 1;
  delete[] a;
}
```

这种方式获得到的也是**连续**的内存，但是 *可以直接使用 `a[n]` 的形式获得到数组的第 n + 1 行（row）的首地址* ，因此，使用 `a[r][c]` 的形式即可访问到下标为 `(r, c)` 的元素。

注意，**由于指向数组的指针也是一种确定的数据类型，因此除数组的第一维外，其他维度的长度均须为一个能在编译器确定的常量**。不然，编译器将无法翻译如 `a[n]` 这样的表达式（`a` 为指向数组的指针）。

```cpp
int(*a)[size2] = new int[size][size2]  //即size2处必须为常量
```



# 字符串

## C风格字符串

C风格字符串实际上是使用 **null 字符 \0** 终止的**一维字符数组**。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。

其实不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把  \0 放在字符串的末尾。

```cpp
char str1[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
char str2[] = "RUNOOB";  // 依据初始化规则，可以将语句写成这种形式
```

C++ 中有大量的函数用来操作以 null 结尾的字符串

| 序号 | 函数 & 目的                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 **+** 号，例如: `string str1 = "runoob"; string str2 = "google"; string str = str1 + str2;` |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |



## C++中的 String 类（待完善

C++ 标准库提供了 string 类类型，支持 C 风格字符串的所有操作，另外还增加了其他更多的功能。

> 到目前为止我们还没有讨论类和对象。可以在理解了面向对象的概念之后再回头来理解这个实例

```cpp
#include <iostream>
#include <string>
 
using namespace std;
 
int main ()
{
   string str1 = "runoob";
   string str2 = "google";
   string str3;
   int  len ;

   // 复制 str1 到 str3
   str3 = str1;
   cout << "str3 : " << str3 << endl;
 
   // 连接 str1 和 str2
   str3 = str1 + str2;
   cout << "str1 + str2 : " << str3 << endl;
 
   // 连接后，str3 的总长度
   len = str3.size();
   cout << "str3.size() :  " << len << endl;
 
   return 0;
}
```





# 结构体

结构体`(struct)`是一种自定义的数据类型，可以将多个**不同类型**的数据组合在一起。

在实际项目中，结构体是大量存在的。研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言无法操作数据库，所以在项目中通过对结构体内部变量的操作将大量的数据存储在内存中，以完成对数据的存储和操作。

**C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。**在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，**C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private。**



## 定义

### 声明结构体

```cpp
struct Object {
  int weight;	//**注意此处用分号区隔**
  int value;
}; //**注意分号不能少，这也相当于一条语句**
```

上例中定义了一个名为 `Object` 的结构体，两个成员元素 `value, weight`，类型都为 `int`。

但是注意，它**并没有创建一个实际的数据对象，而是描述了一个组成这类对象的元素**。因此，我们有时候也将结构体声明叫做模板，因为它勾勒出数据该如何存储，并没有实例化数据对象。



### 定义与初始化结构体变量

下例定义了数据类型为 `Object` 的常量 `a`，变量 `b`，变量 `tmp`，数组 `B`，指针 `c`。对于某种已经存在的类型，都可以使用这里的方法进行定义 *常量、变量、指针、数组* 等。

```cpp
const Object a; //struct是可省略的
Object b, B[array_length], tmp; 
// int b; int B[array_length]; int temp;
Object *c;
```



下例这种方式可以**同时完成结构体的声明、结构体变量的定义与初始化**，且能够同时定义多个结构体变量。

注意，**只能在定义结构体时进行全部赋值**， 后续只能进行单个赋值。

```cpp
    struct languages {
        string name;
        int year;
        char level;
    } python={	//声明内容跟随在结构体名后方，初始化内容跟随在定义的结构体变量名称后方
        "Python",	//成员变量的值用逗号区隔	
        1991,
        'A'
    }, cpp={	//定义多个结构体变量时用逗号区隔
        "C++",
        1985,
        'A'
    };
```

> `{}` 运算符可以用来初始化没有构造函数的结构。除此之外，使用 `{}` 运算符可以使得变量的初始化形式变得统一。



### 访问和修改成员变量

可以使用 `变量名.成员元素名` 进行访问与修改

```
obj.weight = 10;
obj.value = 20;

cout << obj.weight << endl; // 输出 10
obj.value = 30;
cout << obj.value << endl;  // 输出 30
```



### 一些补充

为了访问内存的效率更高，编译器在处理结构中成员的实际存储情况时，可能会将成员对齐在一定的字节位置，也就意味着结构中有空余的地方。因此，该结构所占用的空间可能大于其中所有成员所占空间的总和。



## > 为什么需要结构体？

结构体能够显式地将**成员元素（在算法竞赛中通常是变量）捆绑在一起**，如本例中的 `Object` 结构体，便将 `value,weight` 放在了一起（定义这个结构体的实际意义是表示一件物品的重量与价值）。这样的好处是**限制了成员元素的使用**。

想象一下，如果不使用结构体而且有两个数组 `value[], Value[]`，很容易写混淆。但如果使用结构体，能够减轻出现使用变量错误的几率。

并且不同的结构体（结构体类型，如 `Object` 这个结构体）或者不同的结构体变量（结构体的实例，如上方的 `e` 数组）可以拥有相同名字的成员元素（如 `tmp.value,b.value`），同名的成员元素相互独立（拥有独自的内存，比如说修改 `tmp.value` 不会影响 `b.value` 的值）。

这样的好处是**可以使用尽可能相同或者相近的变量去描述一个物品**。比如说 `Object` 里有 `value` 这个成员变量；我们还可以定义一个 `Car` 结构体，同时也拥有 `value` 这个成员；如果不使用结构体，或许我们就需要定义 `valueOfObject[],valueOfCar[]` 等不同名称的数组来区分。

*如果想要更详细的描述一种事物，还可以定义成员函数。请参考 [类](https://oi-wiki.net/lang/class/) 获取详细内容。*



## > 结构体与类的区别？

在 C++ 中，结构体（`struct`）和类（`class`）有一些相似之处，但也有几个关键的区别：

1. **默认访问权限**：
   - 结构体的成员默认是 `public` 的。
   - 类的成员默认是 `private` 的。
2. **继承**：
   - 结构体的继承默认是 `public` 的。
   - 类的继承默认是 `private` 的。
3. **用法**：
   - 结构体通常用于简单的数据聚合，不包含复杂的成员函数。
   - 类通常用于更复杂的对象，包含成员函数和数据成员。

可以将 `struct` 当作一种简化形式的 `class`，适合用于没有太多复杂功能的简单数据封装。



## 结构体指针

可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似。

指向结构体的指针存储的是**结构体实例的地址**。它保存的是内存中某个结构体的实际位置。当定义一个结构体类型并创建一个结构体实例时，它会分配一块内存来存储结构体的数据，而指向结构体的指针保存的就是这块内存的起始地址。

```cpp
struct Books *struct_pointer;  // 未命名结构体名，直接用指针指定
```

为了使用指向该结构的指针访问结构的成员，通常使用 **->** 运算符，但也可以使用`*`与`.`运算符来进行。

```cpp
struct_pointer->title;  // 表示 struct_point 对应的结构体中的 title 成员变量
```

下面是一个较完整的例子。

```cpp
struct ThreeInt {
	int a;
	int b;
	int c;
};
int main(){
  ThreeInt x{1, 2, 3}, y{6, 7, 8};
  ThreeInt* px = &x;
  (*px) = y;    // x: {6,7,8}
  (*px).a = 4;  // x: {4,7,8}
  px->b = 5;    // x: {4,5,8} 
  return 0;
}
```



可以通过指针访问结构体成员变量。假设 `p` 是一个指向 `Person` 类型的指针，此时`p` 是指向 `p1` 结构体的指针，`p->age` 就是访问 `p1` 结构体中的 `age` 成员。

```cpp
struct Person {
    string name;
    int age;
    int grade;
};
void update(Person* p) {
    p->age += 1;  // 通过指针访问结构体成员
    (*p).grade += 1;
}
int main() {
    Person p1 = {"John", 30};
    cout << "Before: " << p1.name << " " << p1.age << p1.grade << endl;
    update(&p1);
    cout << "After: " << p1.name << " " << p1.age << p1.grade << endl;
    return 0;
}
```



## 向函数传入结构体，从函数返回结构体

可以向函数传入结构体。

按值传递是指将结构体的副本传递给函数，函数内部对结构体的修改不会影响原始结构体。传递时会创建结构体的一个副本，可能会导致内存开销较大，尤其是结构体较大时。

```cpp
#include <stdio.h>

struct Point {
    int x, y;
};

void printPoint(struct Point p) {
    printf("Point coordinates: (%d, %d)\n", p.x, p.y);
}

int main() {
    struct Point p1 = {10, 20};
    printPoint(p1);  // 按值传递
    return 0;
}
```

通过指针传递是将结构体的内存地址传递给函数，这样函数就可以直接访问并修改原始结构体的内容。这种方法更加常用。由于传递的是指针，因此不会复制结构体本身，效率较高，尤其是对于大型结构体来说。

```cpp
#include <stdio.h>

struct Point {
    int x, y;
};

void modifyPoint(struct Point *p) {  // 传递结构体的地址
    p->x = 100;  // 通过指针修改原结构体内容
    p->y = 200;
}

int main() {
    struct Point p1 = {10, 20};
    modifyPoint(&p1);  // 传递结构体的地址
    printf("Modified Point coordinates: (%d, %d)\n", p1.x, p1.y);
    return 0;
}
```



也可以从函数返回结构体。

按值返回结构体。这是最常见的方式，函数直接返回结构体的副本。这种方式虽然会复制结构体，但对于结构体较小或函数调用较少的情况，这种方式足够高效。

```cpp
#include <stdio.h>

struct Point {
    int x, y;
};

// 函数按值返回结构体
struct Point createPoint(int x, int y) {
    struct Point p;
    p.x = x;
    p.y = y;
    return p;  // 返回结构体副本
}

int main() {
    struct Point p1 = createPoint(10, 20);
    printf("Point: (%d, %d)\n", p1.x, p1.y);
    return 0;
}
```

也可以返回指向结构体的指针。

**注意，C++ 不支持在函数外返回局部变量的地址如果返回局部变量的地址**，当函数结束时，局部结构体将被销毁，返回的指针会指向一个已经销毁的内存区域，这样会导致未定义行为。常见的做法是使用**静态结构体**或**动态分配结构体**。

```cpp
#include <stdio.h>
#include <stdlib.h>

struct Point {
    int x, y;
};

struct Point* createPoint(int x, int y) {  // 通过指针返回结构体
    struct Point *p = (struct Point *)malloc(sizeof(struct Point));
    if (p != NULL) {
        p->x = x;
        p->y = y;
    }
    return p;
}

int main() {
    struct Point *p1 = createPoint(10, 20);
    if (p1 != NULL) {
        printf("Point: (%d, %d)\n", p1->x, p1->y);
        free(p1);  // 使用完后记得释放内存
    }
    return 0;
}
```



# `vector`容器（待完善

C++ 中的 `vector` 是一种序列容器，它允许你在运行时**动态**地插入和删除元素。`vector` 是**基于数组**的数据结构，但它可以**自动管理内存**，这意味着你不需要手动分配和释放内存。与 C++ 数组相比，`vector` 具有更多的灵活性和功能，使其成为 C++ 中常用的数据结构之一。

`vector` 具有一些基本特性：

- **动态大小**：`vector` 的大小可以根据需要自动增长和缩小。
- **连续存储**：`vector` 中的元素在内存中是连续存储的，这使得访问元素非常快速。
- **可迭代**：`vector` 可以被迭代，你可以使用循环（如 `for` 循环）来访问它的元素。
- **元素类型**：`vector` 可以存储任何类型的元素，包括内置类型、对象、指针等。

我什么时候需要 `vector` 容器？

- 当你需要一个可以**动态**增长和缩小的数组时。
- 当你需要频繁地在序列的**末尾**添加或移除元素时。
- 当你需要一个可以高效**随机访问**元素的容器时。

>要使用 vector，首先需要包含 **<vector>** 头文件：
>
>```
>#include <vector>
>```



## 创建 `vector` 

```cpp
vector<int> myVector; // 创建一个存储整数的空 vector
vector<int> myVector(5); // 创建一个包含 5 个整数的 vector，每个值都为默认值（0）
vector<int> myVector(5, 10); // 创建一个包含 5 个整数的 vector，每个值都为 10
```



# 类和对象

C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。

类用于指定对象的形式，是一种**用户自定义的数据类型**，它是一种封装了数据和函数的组合。类中的数据称为成员变量，函数称为成员函数。**类可以被看作是一种模板**，可以用来创建具有相同属性和行为的多个对象。



## 定义类与对象

定义一个类需要使用关键字 `class`，然后指定类的名称。类的主体是包含在一对花括号中，包含类的成员变量和成员函数。

定义一个类本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。

关键字 `public` 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 `private` 或 `protecte`，这个我们稍后会进行讲解。

```cpp
class Box
{
   public:  // 访问修饰符 private/public/protected
      double length;   // 成员变量声明
      double Example(void);  // 成员函数**声明**
};
```



类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。

```cpp
Box Box1;          // 声明 Box1，类型为 Box
```



## 访问数据成员

类的对象的**公共**数据成员可以使用直接成员访问运算符 **.** 来访问，私有的成员和受保护的成员则无法直接访问。

```cpp
Box1.height = 5.0; 
Box1.length = 6.0; 
Box1.breadth = 7.0;

Box2.set(16.0, 8.0, 12.0);  
struct example a={16.0, 8.0, 12.0};  // 与结构体不同 
```

```cpp
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      double length;   
      double breadth;  
      double height;   
      double get(void);
      void set( double len, double bre, double hei );
};
// 成员函数定义
double Box::get(void)  // 注意，命名空间发生变化
{
    return length * breadth * height;
}
 
void Box::set( double len, double bre, double hei)
{
    length = len;
    breadth = bre;
    height = hei;
}

int main( )
{
   Box Box1;   // 声明 Box1 对象，类型为 Box     
   Box Box2;              
   double volume = 0.0;     // 用于存储体积
 
   // box 1 详述
   Box1.height = 5.0; 
   Box1.length = 6.0; 
   Box1.breadth = 7.0;
 
   // box 1 的体积
   volume = Box1.height * Box1.length * Box1.breadth;
   cout << "Box1 的体积：" << volume <<endl;
 
   // box 2 详述
   Box2.set(16.0, 8.0, 12.0); 
   volume = Box2.get(); 
   cout << "Box2 的体积：" << volume <<endl;
   return 0;
}
```



## 类成员函数（待完善

类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作**类**的任意对象，可以访问对象中的**所有**成员。

成员函数可以定义在类定义内部，或者单独使用范围解析运算符 **`::`** 来定义。**在类定义中定义的**成员函数将会把函数声明为**内联**的。

> 什么是内联函数：[*内联函数*](##内联函数)

注意，在 :: 运算符之前必须使用**类名**，调用成员函数是在**对象**上使用点运算符（**.**）

```cpp
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      double length;         // 长度
      double breadth;        // 宽度
      double height;         // 高度
 
      // 成员函数声明
      double getVolume(void);
      void setLength( double len );
      void setBreadth( double bre );
      void setHeight( double hei );
};
 
// 成员函数定义
double Box::getVolume(void)
{
    return length * breadth * height;
}
 
void Box::setLength( double len )
{
    length = len;
}
 
void Box::setBreadth( double bre )
{
    breadth = bre;
}
 
void Box::setHeight( double hei )
{
    height = hei;
}
 
// 程序的主函数
int main( )
{
   Box Box1;                // 声明 Box1，类型为 Box
   Box Box2;                // 声明 Box2，类型为 Box
   double volume = 0.0;     // 用于存储体积
 
   // box 1 详述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);
 
   // box 2 详述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
 
   // box 1 的体积
   volume = Box1.getVolume();
   cout << "Box1 的体积：" << volume <<endl;
 
   // box 2 的体积
   volume = Box2.getVolume();
   cout << "Box2 的体积：" << volume <<endl;
   return 0;
}
```



容易敏锐地注意到：

> 类成员函数是类的一个成员，它可以操作**类**的任意对象，可以访问对象中的**所有**成员。

所以不同对象的成员函数与成员变量是可以传来传去的。

如果 `setLength()` 是一个属于 `Box` 类的普通的成员函数，用来修改对象的成员变量，可以通过对象的引用或者直接传递其他对象的成员变量作为参数。

```cpp
class Box {
public:
    double length;
    // setLength 函数接受一个 double 变量作为参数
    void setLength(double len) {
        length = len;
    }
};

int main() {
    Box box1, box2;
    box1.setLength(10.0);  
    box2.setLength(20.0);  
    box1.setLength(box2.length);  // box1.setLength(box2.length) 可以传入 box2 的成员变量
}

```

如果希望**传递整个对象**，而不仅仅是其中的某个成员变量，可以令函数能够接受对象的传入。

```cpp
class Box {
public:
    double length;
    // setLength 函数接受一个 Box 对象作为参数
    void setLength(Box &otherBox) {  // 使用引用来传递对象是推荐的作法
        length = otherBox.length;
    }
};

int main() {
    Box box1, box2;
    box2.length = 15.0;
    box1.setLength(box2);  // box1.setLength(box2) 让 box1 的 length 等于 box2 的 length
}

```

如果 `setLength` 函数是 `const` 成员函数（即 `void setLength(double len) const`），那么它不能修改成员变量。这种情况下，你不能传入任何对象来修改它的成员变量。

如果 `setLength` 函数需要修改多个 `Box` 对象的成员，那么可以将多个对象作为参数传递，前提是这些对象在调用时可用。



### >  为什么操作成员函数外的成员变量不需要使用指针？

类的成员变量是**隐式地与对象实例相关联的**。

在每个成员函数中，**C++ 会隐式地传递一个 `this` 指针，其指向当前对象**。例如，在 `set` 函数内部，`this->length`、`this->breadth` 和 `this->height` 指的是当前对象的成员变量；在调用 `box1.set(1.0, 2.0, 3.0)` 时，`this` 将指向 `box1`，也就是当前对象。这样，`this->length` 就是对 `box1` 的 `length` 成员进行赋值。不需要手动传递指针，因为编译器会自动处理。

成员函数 `set` 属于某个具体的 `Box` 对象，所以它直接访问对象的成员变量是完全合法的。**这些成员变量的作用域在整个类中有效**，因此直接使用它们无需通过指针或引用。



## 类访问修饰符（？

**数据封装**是面向对象编程的一个重要特点，它**防止函数直接访问类类型的内部成员**。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为访问修饰符。

> 数据封装是面向对象编程中的一个重要概念，也是 C++ 中的核心特性之一。它指的是将数据（即对象的属性或成员变量）与操作这些数据的代码（即成员函数）绑定在一起，并且通过**访问控制机制**对数据的访问进行控制，从而实现对数据的保护和管理。
>
> 在 C++ 中，数据封装通过以下两种方式实现：
>
> 1. **将数据隐藏起来（信息隐藏）**：通过访问控制机制（如 `private` 和 `protected`）限制外部代码对类内部数据的访问。
> 2. **通过公有接口访问数据**：通过提供公共的成员函数（通常是 `getter` 和 `setter` 函数）来控制对数据的访问。

一个类可以有**多个** public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的**默认访问修饰符是 private**。

`public` 成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值。`private` 成员变量或函数在类的外部是不可访问的，甚至是不可查看的，只有类和友元函数可以访问私有成员。`protected`  成员变量或函数与私有成员十分相似，但其成员**在派生类（即子类）中是可访问的**。

> 实际操作中，我们一般会**在私有区域定义数据，在公有区域定义相关的函数**，以便在类的外部也可以调用这些函数，

```cpp
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      double length;
      void setWidth( double wid );
      double getWidth( void );
   private:
      double width;
};
double Box::getWidth(void)
{
    return width ;
}
void Box::setWidth( double wid )
{
    width = wid;
}

int main( )
{
   Box box;
   // 不使用成员函数设置长度
   box.length = 10.0; // OK: 因为 length 是公有的
   cout << "Length of box : " << box.length <<endl;

   // 不使用成员函数设置宽度
   // box.width = 10.0; // Error: 因为 width 是私有的
   box.setWidth(10.0);  // 使用成员函数设置宽度
   cout << "Width of box : " << box.getWidth() <<endl;
 
   return 0;
}
```

### 继承中的特点（？

有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。

- **public 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
- **protected 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
- **private 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

但无论哪种继承方式，下面两点都没有改变：

- `private` 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
- `protected` 成员可以被派生类访问。



## 类构造函数 & 析构函数

类的构造函数是类的一种特殊的成员函数，它会在**每次创建类的新对象时执行**。**构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 `void`**。

构造函数在对象创建时自动执行，可用于为某些成员变量设置初始值。

默认的构造函数**没有任何参数**，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值。

函数的初始化列表允许在**构造函数**的函数体执行之前，为对象的成员变量（包括常量成员、引用成员和基类成员）提供初始值；其顺序依照变量在类中声明的顺序，而非初始化时的顺序。

> 为什么要需要初始化列表？
>
> - 常量成员和引用成员： 常量成员变量 (`const`) 和引用成员变量（`reference`）必须在初始化时进行初始化。因为它们不能在构造函数体内进行赋值，只能通过初始化列表进行初始化。
>
> - 效率： 使用初始化列表可以避免某些成员变量先被默认构造（通过默认构造函数），然后再在构造函数体内赋值的情况。这样可以提高效率，尤其是在成员是复杂类型或对象时

```cpp
Line::Line( double len): length(len), witdth(wid)
{
    cout << "Object is being created, length = " << len << endl;
}
```

上面的语法等同于如下语法：

```cpp
Line::Line( double len)
{
    length = len;
    width = wid;
    cout << "Object is being created, length = " << len << endl;
}
```



类的析构函数是类的一种特殊的成员函数，它会在**每次删除所创建的对象时执行**。**析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数**。

析构函数在对象生命周期结束时会自动执行，有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

```cpp
#include <iostream>
 
using namespace std;
 
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line();   // 这是构造函数声明
      // Line (10);  构造函数也可以带有参数
      ~Line();  // 这是析构函数声明
   private:
      double length;
};

Line::Line(void)
{
    cout << "Object is being created" << endl;
}
Line::~Line(void)
{
    cout << "Object is being deleted" << endl;
}
void Line::setLength( double len )
{
    length = len;
}
double Line::getLength( void )
{
    return length;
}

int main( )
{
   Line line;
   line.setLength(6.0); 
   cout << "Length of line : " << line.getLength() <<endl;
 
   return 0;
}
```



## 拷贝构造函数（待完善

拷贝构造函数是一种特殊的**构造函数**，它在创建对象时**使用同一类中之前创建的对象来初始化新创建的对象**。如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类**带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数**。

拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来**初始化**新创建的对象。
- 复制对象把它**作为参数传递给函数**。
- 复制对象，并从函数**返回这个对象**。

 `obj` 是一个对象引用，该对象是用于初始化另一个对象的。一般情况下，参数必须是**常量引用 `const ClassName&`**，否则可能导致无法拷贝 `const` 对象。

```cpp
classname (const classname &obj) {
   // 构造函数的主体
}
```

拷贝构造函数和普通构造函数在用途上是**不同的**，两者不能相互替代。如果我们只定义拷贝构造函数，而不定义普通构造函数，编译器会报错，因为 `A obj1(10);` 需要一个普通构造函数，而 `A` 只提供了拷贝构造函数。

```cpp
class A {
public:
    A(const A &obj) { x = obj.x; }
    int x;
};

int main() {
    A obj1;  // ❌ 编译错误：没有默认构造函数
}
```



````cpp
#include <iostream>
 
using namespace std;
 
class Line
{
   public:
      int getLength( void );
      Line(int len );             // 简单的构造函数
      Line(const Line &obj);      // 拷贝构造函数
      ~Line();                    // 析构函数
   private:
      int *ptr;
};
 
// 成员函数定义，包括构造函数
Line::Line(int len)
{
    cout << "调用构造函数" << endl;
    // 为指针分配内存
    ptr = new int;
    *ptr = len;
}
Line::Line(const Line &obj)
{
    cout << "调用拷贝构造函数并为指针 ptr 分配内存" << endl;
    ptr = new int;
    *ptr = *obj.ptr; // 拷贝值
}
Line::~Line(void)
{
    cout << "释放内存" << endl;
    delete ptr;
}
int Line::getLength( void )
{
    return *ptr;
}
void display(Line obj)
{
   cout << "line 大小 : " << obj.getLength() <<endl;
}

int main( )
{
   Line line1(10);

   Line line2 = line1; // 这里也调用了拷贝构造函数
 
   display(line1);
   display(line2);
 
   return 0;
}
````



## 友元函数

类的友元函数是**定义在类外部**，但**有权访问类的所有私有成员和保护成员**的函数。尽管友元函数的原型有在类的定义中出现过，但是友元函数**并不是成员函数**。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

```cpp
#include <iostream>
 
using namespace std;
 
class Box
{
   double width;
public:
   friend void printWidth( Box box );  // 友元函数
   void setWidth( double wid );
};

void Box::setWidth( double wid )
{
    width = wid;
}
// 注意：printWidth() 不是任何类的成员函数
void printWidth( Box box )  // 向 printWidth() 传入整个对象 box
{
   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
   cout << "Width of box : " << box.width <<endl;
}
 
int main( )
{
   Box box;
   box.setWidth(10.0);
   printWidth( box );
   return 0;
}
```



## 内联函数

内联函数 是 C++ 中的一种优化机制，它允许函数在调用时 **直接展开** 到调用处，而不是通过常规的函数调用机制（即压栈、跳转、返回等）。这样可以 **减少函数调用的开销**，尤其是在**小型、频繁调用的函数**中提升性能。



# 动态内存管理

## 堆栈

### 栈

栈内存是由编译器自动管理的，它的特点是快速和有序。栈遵循“先进后出”（LIFO, Last In First Out）的原则。栈内存通常用于存储 *局部变量* 、 *函数参数* 以及 *函数调用时的返回地址* 等。

适合存储生命周期明确、大小固定的数据，且不需要跨函数调用共享的变量。

栈有如下特性：

1. **分配和释放速度快**：当函数被调用时，栈会自动分配空间，函数返回时，栈空间也会自动回收。这个过程不需要程序员手动管理，因此内存分配和回收速度非常快。

2. **空间有限**：栈的大小是有限的，通常由操作系统决定，因此栈的容量远小于堆。栈的大小通常为几MB到几十MB不等。如果栈的空间用尽，就会发生栈溢出（Stack Overflow）。

3. **自动管理**：栈中的内存由编译器自动管理，不需要显式的内存释放。

4. **数据存放结构**：栈中的数据按顺序存储，每当一个函数调用时，它的局部变量和参数被压入栈中；函数调用结束后，它们会从栈中弹出，内存空间被自动释放。



### 堆

堆内存则是由程序员**手动管理**的，它用于存储动态分配的内存。通过`new`和`delete`（在`C++`中）来分配和释放内存。

适合存储不确定大小的数据，或者需要在多个函数之间共享的动态数据。

堆有如下特性：

1. **分配和释放速度较慢**：堆内存的分配和回收比栈慢，因为它是动态的，需要通过操作系统的内存管理进行分配。且程序员需要显式地释放这块内存，否则会发生内存泄漏。
2. **空间大**：堆的内存空间相对于栈来说通常较大，通常由操作系统提供，几GB的内存也可以在堆中进行分配。
3. **手动管理**：程序员必须在使用`new`分配内存后，使用`delete`释放内存。如果程序员忘记释放，就会导致内存泄漏。
4. **灵活性**：堆内存允许动态地分配任意大小的内存，大小和生命周期都不受栈空间的限制。通过指针来访问堆中的数据，因此需要注意指针的有效性。



## 动态实例化

动态实例化是指在程序运行时，**由程序员根据需要创建对象或分配内存，而不是在编译时决定对象的创建**。这通常是通过动态内存分配来实现的，即在程序运行时通过`new`、`malloc`等函数在堆（heap）上创建对象或数组，而不是在栈（stack）上创建局部变量。

当程序通过调用操作系统接口申请内存时，操作系统将返回程序所申请空间的地址。要使用这块空间，我们需要将这块空间的地址存储在指针变量中。

在 C++ 中，我们使用 `new` 运算符来获取一块内存，**使用完毕必须用 `delete` 运算符释放某指针所指向的空间，以防内存泄漏。**

动态实例化是管理复杂内存需求的核心手段，合理使用能显著提升程序的灵活性和效率。

```cpp
struct ThreeInt {
  int a;
  int b;
  int c;
};

int main() {
  int* pInt = new int(5); 
  ThreeInt* pStruct = new ThreeInt{1, 2, 3}; 
  						threeInt Struct = {1,2,3}
  //**未给出结构体变量名，直接通过指针地址访问**
    
  int (*pArr)[5] = new int[5];
  			   	  int Arr[5]
    
  delete p;
}
```

### > 与静态实例化有什么区别?

静态实例化是**在编译时就决定了对象的创建和内存分配**，通常发生在栈上。比如，函数内部的局部变量、全局变量、静态变量等，都是静态实例化的对象。它们的内存地址和生命周期在编译时就已经确定。

```cpp
int x = 10;  // 静态实例化，x的内存位置在栈上
```

动态实例化是在程序运行时，根据需要动态地分配内存并创建对象。通过动态内存分配，程序可以在运行时创建任意数量的对象或数组，内存空间通常来自堆。

```cpp
int* x = new int(10);  // 动态实例化，x指向堆中的内存
```



### > 为什么需要指针动态实例化对象？

指针动态实例化对象，通常是通过`new`操作符在堆区分配内存并初始化对象。这种方式在某些情况下特别重要，因为它允许**更灵活的内存管理和对象生命周期控制**。

---

1. **灵活控制对象的生命周期**

   - **栈内存的局限性**：函数内局部变量（栈内存分配）会在作用域结束时自动销毁，无法长期存在。

   - **堆内存的持久性**：动态分配的对象存在于堆内存中，生命周期由开发者手动控制（通过`new`创建，`delete`释放）。  

     应用场景：当对象需要**跨函数、跨作用域存在时（例如全局缓存、单例对象）**

---

2. **运行时动态决定内存需求**

   - 动态实例化允许程序在运行时根据实际数据量或用户输入决定内存分配大小。

     对于**大小不固定的数组或数据结构**，如链表、树、图等数据结构，必须在运行时动态创建；

     对于**大型数据的内存管理**，例如动态生成的图像、视频帧等。同时如果使用指针在堆上创建对象，可以避免栈溢出的问题，因为堆的内存空间通常远大于栈。

     示例：

     ```cpp
     int size = getUserInputSize();
     int* dynamicArray = new int[size]; // 动态数组
     ```

     静态数组无法实现这一点，因为其大小必须在编译时确定。

---

3. **避免不必要的拷贝，提升性能**

   - 传递指针（或引用）比直接传递大型对象更高效，减少内存拷贝开销。  
     **对比**：

     ```cpp
     void processObject(BigObject obj);  // 值传递：拷贝整个对象
     void processObject(BigObject* obj); // 指针传递：仅拷贝地址（4/8字节）
     ```

---

4. **实现多态和抽象接口**

   - 通过基类指针指向派生类对象，实现运行时多态（动态绑定）。  
     **示例**：

     ```cpp
     class Animal { public: virtual void speak() = 0; };
     class Dog : public Animal { void speak() override { cout << "Woof!"; } };
     class Cat : public Animal { void speak() override { cout << "Meow!"; } };
     
     Animal* animal = new Dog(); // 动态实例化具体子类
     animal->speak(); // 输出 "Woof!"
     ```

---

5. **构建动态数据结构**

   - 链表、树、图等动态数据结构依赖指针连接节点，节点数量在运行时动态变化。  
     **链表节点示例**：

     ```cpp
     struct Node {
         int data;
         Node* next; // 必须用指针指向下一个节点
     };
     Node* head = new Node();
     ```

---

6. **资源共享与所有权管理**

   - 多个对象可通过指针共享同一份数据，避免重复存储。  
     **示例**：多个GUI窗口共享同一份配置数据。
   - 结合智能指针（如`std::shared_ptr`）可自动管理资源释放，避免内存泄漏。

---

7. **延迟初始化（Lazy Initialization）**

   - 仅在需要时创建对象，优化启动性能。  
     **示例**：

     ```cpp
     class HeavyResource {
     private:
         static HeavyResource* instance;
     public:
         static HeavyResource* getInstance() {
             if (!instance) instance = new HeavyResource(); // 首次调用时创建
             return instance;
         }
     };
     ```

---



### > 有哪些需要动态实例化的场景?

| 场景                                                 | 动态实例化的意义                           |
| ---------------------------------------------------- | ------------------------------------------ |
| 不确定数据规模                                       | 动态分配内存（如文件读取、网络数据包处理） |
| 多态与接口抽象                                       | 通过基类指针操作派生类对象                 |
| 高频创建/销毁对象                                    | 内存池技术优化性能                         |
| **跨函数、跨作用域存在时（例如全局缓存、单例对象）** | 延长对象生命周期                           |

 注意事项：

- **内存泄漏风险**：动态分配后需手动释放（或使用智能指针）。
- **现代C++替代方案**：优先使用`std::make_unique`、`std::make_shared`等智能指针，而非裸指针和`new`/`delete`。



## 动态分配数组

可以使用 `new[]` 运算符创建数组，**这时 `new[]` 运算符会返回数组的首地址，也就是数组第一个元素的地址**，我们可以用对应类型的指针存储这个地址。

```cpp
size_t element_cnt = 5;
int *p = new int[element_cnt];

p[0] = 10;  //指针变量名同时也成为数组名
int x = p[0];

*(p + 0) = 10;  // 直接通过指针访问元素，等同于 p[0] = 10;
for (int i = 0; i < size; ++i) {
    p[i] = i;  // 填充数组
}
for (int i = 0; i < size; ++i) {
    cout << p[i] << " ";  // 输出数组元素
}

delete[] p;   // 释放内存
```

### 动态数组与变长数组

我实现的是动态数组吗？

``` cpp
int size = getUserInputSize();
int* dynamicArray = new int[size]; //动态数组

int size;
int arri[size];//变长数组
```

不是的。这样的数组仍然存储在栈内存中。

注意在某些编译器中（如 GCC），你可以在运行时根据某个值（例如 `size`）来定义数组大小，但这**并不符合标准 C++**。





